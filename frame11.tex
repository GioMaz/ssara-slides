% Errors

\begin{onlyenv}<1>
\begin{minipage}{0.58\linewidth}
\begin{lstlisting}[style=Rocq, basicstyle=\footnotesize\ttfamily]
CoFixpoint example_block_1 :=
  Block (Normal 1) [] [
    r(0) <- i(5);
    r(1) <- r(0)
  ] (jump example_block_2).

with example_block_2 :=
  Block (Normal 2) [
    r(2) <- phi [(0, Normal 1); (4, Normal 2)];
    r(3) <- phi [(1, Normal 1); (5, Normal 2)]
  ] [
    r(4) <- r(2) - i(1);
    r(5) <- r(3) * r(4)
  ] (if r(4) <= i(1)
    then example_block_3
    else example_block_2).

with example_block_3 :=
  Block (Normal 3) [] [] (ret r(5)).
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.38\linewidth}
\begin{lstlisting}[style=NASM, basicstyle=\footnotesize\ttfamily]
L1:
	mov	rcx,	5
	mov	rbx,	rcx
	jmp	L2
L2:
	sub	rcx,	1
	imul	rbx,	rcx
	cmp	rcx,	1
	jle	L2.1
	jmp	L2.2
L2.1:
	jmp	L3
L3:
	mov	rax,	60
	mov	rdi,	rbx
	syscall	
L2.2:
	jmp	L2
\end{lstlisting}
\end{minipage}
\end{onlyenv}

% \begin{alertblock}{NASM Generation}
%     We extract the Rocq program to OCaml. We compose the register assignment pipeline into the \texttt{regassign} function. Finally, we compare the results of some programs.
% \end{alertblock}

% \inferrule*[Right=SimplicialSingleton]
%     {u \not \in V}
%     {\simplicial{u}{G+u}}
% \\
% \inferrule*[Right=SimplicialNode]
%     {\simplicial{u}{G} \\ u \neq v}
%     {\simplicial{u}{G + v}}
% \\
% \inferrule*[Right=SimplicialEdge]
%     {\simplicial{u}{G} \\ u \neq v' \\ u \neq v''}
%     {\simplicial{u}{G + \{ v', v''\}}}
% \\
% \inferrule*[Right=SimplicialNeighbor]
%     {\simplicial{u}{G}}
%     {\simplicial{u}{\addvertex{G}{N(u)}{v}}}


% \only<1>{
% \[
% \renewcommand{\arraystretch}{1}
% \begin{array}{l}
% B_1 := \text{Block (Normal 1) } [] \ [ \\
% \quad r(0) \leftarrow i(0); \\
% ] \ (\text{jump } B_2) \\
% \\
% B_2 := \text{Block (Normal 2) } [ \\
% \quad r(2) \leftarrow \phi[(0, \ \text{Normal 1}); \ (3, \ \text{Normal 2})] \\
% ] \ [ \\
% \quad r(3) \leftarrow r(2) + 1 \\
% ] \ (\text{if } r(3) < 20 \text{ then } B_2 \text{ else } B_3) \\
% \\
% B_3 := \text{Block (Normal 3) } [] \ [] \ (\text{ret } r(6)) \\
% \end{array}
% \]
% }

% \only<2>{
% \[
% \renewcommand{\arraystretch}{1}
% \begin{array}{l}
% B_1 := \text{Block (Normal 1) } [] \ [ \\
% \quad r(\text{RBX}) \leftarrow i(0); \\
% ] \ (\text{jump } B_2) \\
% \\
% B_2 := \text{Block (Normal 2) } [ \\
% \quad r(\text{RBX}) \leftarrow \phi[(\text{RBX}, \ \text{Normal 1}); \ (\text{RBX}, \ \text{Normal 2})] \\
% ] \ [ \\
% \quad r(\text{RBX}) \leftarrow r(\text{RBX}) + 1 \\
% ] \ (\text{if } r(\text{RBX}) < 20 \text{ then } B_2 \text{ else } B_3) \\
% \\
% B_3 := \text{Block (Normal 3) } [] \ [] \ (\text{ret } r(\text{RBX})) \\
% \end{array}
% \]
% }